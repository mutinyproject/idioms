'\" t
.\"     Title: match
.\"    Author: [see the "AUTHOR(S)" section]
.\" Generator: Asciidoctor 2.0.10
.\"      Date: 2020-06-10
.\"    Manual: Mutineer's Guide
.\"    Source: Mutiny
.\"  Language: English
.\"
.TH "MATCH" "1" "2020-06-10" "Mutiny" "Mutineer\(aqs Guide"
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.ss \n[.ss] 0
.nh
.ad l
.de URL
\fI\\$2\fP <\\$1>\\$3
..
.als MTO URL
.if \n[.g] \{\
.  mso www.tmac
.  am URL
.    ad l
.  .
.  am MTO
.    ad l
.  .
.  LINKSTYLE blue R < >
.\}
.SH "NAME"
match \- return 0 if all strings match the pattern given, return 1 if they do not.
.SH "SYNOPSIS"
.sp
\fBmatch\fP [\fB\-E\fP|\fB\-F\fP] [\fB\-a\fP] \fIPATTERN\fP \fISTRING\fP...
.SH "OPTIONS"
.sp
\fB\-E\fP
.RS 4
Use extended regular expressions. This corresponds to grep(1)\(aqs \-E option.
If specified along with \fB\-F\fP, the last specified argument takes priority.
.RE
.sp
\fB\-F\fP
.RS 4
Use a fixed, literal string. This corresponds to grep(1)\(aqs \-F option.
If specified along with \fB\-E\fP, the last specified argument takes priority.
.RE
.sp
\fB\-a\fP
.RS 4
Check if \fIany\fP string matches, not all.
.RE
.SH "EXIT STATUS"
.sp
\fB0\fP
.RS 4
All strings matched. If \fB\-a\fP was given, there was at least one match.
.RE
.sp
\fB1\fP
.RS 4
There was not a match.
.RE
.SH "EXAMPLES"
.sp
.if n .RS 4
.nf
if match \-E "[0\-9]{4}\-[0\-9]{2}\-[0\-9]{2}" "1998\-05\-28";then
    echo "that was a date!"
else
    echo "please give a date instead"
fi
.fi
.if n .RE
.SH "RATIONALE"
.sp
The goal of match(1) is to prevent ugly regular expression matching in scripts. There\(cqs a few
ways to do this.
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
With expr(1)\(aqs match function, which doesn\(cqt support extended regular expressions or fixed
strings, and has added baggage due to POSIX.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
With grep(1) reading from standard input, counting the amount of matches. This is how match(1)
actually does it internally, but it looks pretty ugly and there\(cqs a multitude of ways to do this
one simple task with it. One could also check the output of grep(1) to see if it outputs
anything.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.  sp -1
.  IP \(bu 2.3
.\}
Usage of bash(1)\(aqs \f(CR=~\fP test as part of its \f(CR[[\fP syntax.
.RE
.sp
With the exception of bash, most of these are pretty ugly. There\(cqs no need for a shell extension, as
this is something which certainly can be done POSIXly; using match(1), this becomes a more uniform
action to perform as there\(cqs just one way to do it and it\(cqs not a particularly ugly way either.
This leads to more readable scripts with less magic\-looking code.
.SH "SEE ALSO"
.sp
expr(1), grep(1)
.SH "BUGS"
.sp
There\(cqs an IRC channel for this and other utilities at \c
.URL "irc://irc.freenode.net/#mutiny" "" "."
Please don\(cqt hesitate to message if you have questions.
.SH "LICENSE"
.sp
\fBmatch\fP is in the public domain.
.sp
To the extent possible under law, Kylie McClain has waived all copyright and related or neighboring
rights to this work.
.sp
.URL "http://creativecommons.org/publicdomain/zero/1.0/" "" ""