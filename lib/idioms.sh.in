#!/bin/sh

if [ -z "${NO_COLOR}" ]; then
    color_red=$(printf '\e[31m')
    color_yellow=$(printf '\e[33m')
    color_blue=$(printf '\e[34m')
    color_bold=$(printf '\e[1m')
    color_reset=$(printf '\e[0m')
fi

stderr() {
    printf "$@" >&2
}

note() {
    local msg
    msg="${1}"
    shift

    printf "${color_bold}${color_blue}::${color_reset} ${msg}" "$@"
}

warning() {
    local msg
    msg="${1}"
    shift

    stderr "${color_bold}${color_yellow}??${color_reset} ${msg}" "$@"
}

error() {
    local die msg
    die=false
    msg=

    case "${1}" in
        -d)
            die=true
            ;;
    esac

    [ $# -gt 0 ] || { printf "usage: %s [-d] FORMAT\n" "error"; return 127; }

    msg="${1}"
    shift

    stderr "${color_bold}${color_red}!!${color_reset} ${msg}" "$@"
}

die() {
    local arg errno
    errno=1

    while getopts :e: arg >/dev/null 2>&1; do
        case "${arg}" in
            e)
                errno="${OPTARG}"
                ;;
            ?)
                error "unknown argument -- %s\n" "${OPTARG}"
                printf "usage: %s [-e ERRNUM] FORMAT\n" "die"
                return 127
                ;;
        esac
    done
    shift $((OPTIND - 1))
    
    [ $# -gt 0 ] && stderr "$@"
    exit "${errno}"
}

run() {
    local dry_run err_code keep_going
    dry_run=false
    err_code=
    keep_going=false

    while [ $# -gt 0 ]; do
        case "$1" in
            -*)
                :
                ;;
            *)
                break
                ;;
        esac

        case "$1" in
            -k)
                keep_going=true
                ;;
            -n)
                dry_run=true
                ;;
        esac
        shift
    done

    stderr "+ %s\n" "$*"
    if ! "${dry_run}"; then
        "$@" || {
            err_code=$?
            "${keep_going}" || error -d "command \`%s\` exited with %s\n" "$*" "${err_code}"
        }
    fi
}

